# -*- coding: utf-8 -*-
"""MNIST Bernoulli_Naive_Bayes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dzUC8X2DsqU2s7LdgawzmhZh6oK4ULH8
"""

import numpy as np
from sklearn.datasets import fetch_openml
from google.colab import files
files.upload()
import naive_bayes  # Import your custom module

# Download the MNIST dataset from scikit-learn
mnist = fetch_openml('mnist_784')
X, y = mnist.data, mnist.target

# Print the shape of the original data
print(f"Original data shape: {X.shape}")

# Convert pixel values to binary representation using a threshold
#The pixel values in the dataset are converted into binary representations using a threshold of 0.5.
#Values above the threshold are set to 1, and values below the threshold are set to 0.
threshold = 128
X_binary = (X > threshold).astype(int)

# Print the shape of the binary data
print(f"Binary data shape: {X_binary.shape}")

# Split the data into training and testing sets
split_ratio = 0.8  # 80% for training, 20% for testing
split_index = int(X_binary.shape[0] * split_ratio)
train_images, test_images = X_binary[:split_index], X_binary[split_index:]
train_labels, test_labels = y[:split_index], y[split_index:]

# Print the shapes of the training and testing sets
print(f"Training data shape: {train_images.shape}, Training labels shape: {train_labels.shape}")
print(f"Testing data shape: {test_images.shape}, Testing labels shape: {test_labels.shape}")

# Initialize and train the Bernoulli Naive Bayes classifier
bnb = BernoulliNaiveBayes()
bnb.fit(train_images, train_labels)

# Make predictions on the test set
test_images = np.array(test_images, dtype=np.float)
test_predictions = bnb.predict(test_images)

# Evaluate the classifier
correct_predictions = (test_predictions == test_labels)
accuracy = sum(correct_predictions) / len(test_labels)
print(f"Accuracy: {accuracy * 100:.2f}%")

from sklearn.metrics import accuracy_score
accuracy_sc= accuracy_score(test_labels, test_predictions)
print(f"Accuracy: {accuracy_sc * 100:.2f}%")